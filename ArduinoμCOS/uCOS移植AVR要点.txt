
一、阅读须知
1。移植uC/OS Ⅱ版本为V2.86。
2。移植所用的编译器为IAR Embedded Workbench for AVR(V5.40.1)。
3。代码调试工具为AVR Studio(V4.18)。
4。移植平台分别为AVR Atmega168、Atmega1280、Atmega2560。
5。此次移植工程的路径与官方版本不一致，修改如下：
PRJ:.
├─Doc
├─AppNotes
└─code
    ├─TEST
    │  ├─settings
    │  └─Debug
    │      ├─Exe
    │      ├─Obj
    │      └─List
    ├─OS Source
　　└─Atmega168
其中，DOC文件夹包含官方提供的uC/OS Ⅱ说明文档；AppNotes文件夹包含Atmega168 
datasheet以及移植指南，例如编译器的设置(针对Atmega128的，但大同小异)；TEST文件
夹是为测试本次移植所创建的一个示例工程；OS Source文件夹包含uC/OS Ⅱ V2.86全部
文件；Atmega168文件夹包含移植所需要的Atmega168底层代码。
6。uCOS On ATmega168.PR是Source Insight(V3.50)特有的工程文件，用于代码阅读。其他
类同。



二、移植前的准备工作
1。需了解uC/OS Ⅱ内核结构。至少需要知道uC/OS Ⅱ任务调度实现原理和方式。
2。需了解Atmega汇编系统。
3。需了解Atmega中断系统。
4。需了解uC/OS Ⅱ移植所涉及的文件及其作用(os_cpu.h、os_cpu.c、os_cpu.asm)。












三、移植过程
1。修改os_cpu.h
ⅰ.根据Atmega字长(8 Bit)和编译器对变量的处理，进行恰当的类型定义。OS_STK和
OS_CPU_SR特别重要。

ⅱ.根据Atmega的中断系统特性，修改OS_CRETICAL_METHOD(临界段代码保护方式)。
此次移植采用的是方式3，即是进入临界段代码时，将SREG压入当前任务堆栈，同时清除
SREG的I(全局中断时能)；在退出时只需弹出SREG即可。

ⅲ.AVR单片机堆栈生长方式为向下生长，定义OS_STK_GROWTH为1。


2。修改os_cpu.c
ⅰ.为uC/OS Ⅱ定义几个与任务调度相关的钩子程序，如OSInitHookBegin()、
OSInitHookEnd()；OSTaskCreateHook()、OSTaskDelHook()等。如无特别需要，只需定义，
函数体可以为空。

ⅱ. OSTaskStkInit()在创建任务的时候会被调用。用于初始化相应任务的堆栈，作为该任
务第一次调度时的堆栈。此时压栈顺序应该和此后进行的任务调度压栈顺序一致。
※需要特别注意的是：
①变量OSTaskStkSize和OSTaskStkSizeHard须在调用OSInit()前进行一次恰当的初始化
(为创建空闲任务所使用)。
②如果为各个任务分配的堆栈空间大小不一致，可在用户创建任务时再次修改
OSTaskStkSize和OSTaskStkSizeHard。
③此时的R16、R17用于存储任务参数，此后作用会有所改变。
④另外，OSTaskStkInit()已经将全局中断使能打开。
⑤OSTaskStkInit()总的来说完成了一次任务堆栈的压入操作，为任务堆栈初始化，尤其是
SPH和SPL。
















3。修改os_cpu.asm(工程中命名为os_cpu_a.s90)
ⅰ.OSStartHighRdy()的标准伪代码如下：
void OSStartHighRdy(void)
{
       调用用户定义的OSTaskSwHook();
       OSRunning = TRUE;
       得到将要恢复运行的任务的堆栈指针：
              Stack Pointer = OSTCBHighRdy——>OSTCBStkPtr;
       ●从新任务堆栈中恢复处理器的所有寄存器;
       ●●执行中断返回指令;
}
●为防止意外的中断破坏恢复任务现场，在弹出SREG的时候应该将I位清零。
●●执行中断返回指令RETI，可以将SREG的I位置1
●●●OSStartHighRdy()由OSStart()调用，并且永不返回。
●●●●OSStartHighRdy()用于启动uC/OS Ⅱ任务调度。

ⅱ.OSCtxSw()的标准伪代码如下：
void OSCtxSw(void)
{
       保存处理器寄存器;
       在当前任务的任务控制块中保存当前任务的堆栈指针：
              OSTCBCur——>OSTCBStkPtr = Stack Pointer;

       OSTaskSwHook();########################################
       OSTCBCur = OSTCBHighRdy;###############################
       OSPrioCur = OSPrioHighRdy;############################
       得到将要运行的任务的堆栈指针：
              Stack Pointer = OSTCBHighRdy——>OSTCBStkPtr;##
      ●从新任务的任务堆栈中恢复处理器所有寄存器的值;########
      ●●执行返回指令;######################################
}
●为防止意外的中断破坏任恢复务现场，在弹出SREG的时候应该将I位清零(如果I位已经
置1)。
●●如果I位在当前已就绪的最高优先级任务是置1的，执行RETI指令，否则执行RET指
令。
●●●OSCtxSw()用于常规的任务调度，可能由OSTimeDly()等引起的。
●●●●并不是所有的任务都需要中断。







ⅲ. OSIntCtxSw()的标准伪代码如下：
void OSIntCtxSw(void)
{
       OSTaskSwHook();########################################
       OSTCBCur = OSTCBHighRdy;###############################
       OSPrioCur = OSPrioHighRdy;############################
       得到将要运行的任务的堆栈指针：
              Stack Pointer = OSTCBHighRdy——>OSTCBStkPtr;##
      ●从新任务的任务堆栈中恢复处理器所有寄存器的值;########
      ●●执行返回指令;######################################
}
●为防止意外的中断破坏任恢复务现场，在弹出SREG的时候应该将I位清零(如果I位已经
置1)。
●●如果I位在当前已就绪的最高优先级任务是置1的，执行RETI指令，否则执行RET指
令。
●●●OSIntCtxSw()用于中断级的任务调度，由定时器中断引起的。也就是一个滴答。
●●●●并不是所有的任务都需要中断。
●●●●●你会发现，OSIntCtxSw()与OSCtxSw()的大部分代码是一样的，只是OSIntCtxSw()
不需要保存任务现场。

ⅳ. OSTickISR()的标准伪代码如下：
void OSTickISR(void)
{
       ●保存处理器寄存器;
       调用OSIntEnter()或者直接给OSIntNesting加1;
       if(OSIntNesting == 1)
       {
              OSTCBCur——>OSTCBStkPtr = Stack Pointer;
       }
       给产生中断的设备清中断;
       重新使能允许中断（可选）;
       OSTimeTick();
       ●●OSIntExit();
       恢复处理器寄存器;
       ●●●执行中断返回指令;
}
●保存任务现场，SREG存入R16后，需将R16的最高位(对应着I)置1后方可压入任务堆栈。
●●如果有任务需要调度，OSIntExit()将会调用OSIntCtxSw()以完成任务切换。
●●●如果没有任务需要调度，则在恢复任务现场后直接执行RETI退出。
●●●●OSTickISR()已经为OSIntCtxSw()保存了任务现场。
●●●●●你会发现，OSCtxSw()和OSTickISR()其实没什么两样。uC/OS Ⅱ正是通过模拟
一次中断来进行任务调度的。


4。修改os_cfg.h
ⅰ.os_cfg.h是用于裁剪uC/OS Ⅱ的配置文件，按需配置即可。


5。特别说明
ⅰ.为了减少uC/OS Ⅱ对RAM的使用，修改uC/OS Ⅱ核心代码os_core.c中OSUnMapTbl
的存储空间。由INT8U  const  OSUnMapTbl[256]修改为 __flash INT8U  const  
OSUnMapTbl[256],__flash关键字仅在IAR Embedded Workbench for AVR下有效。

ⅱ.AVR系列单片机指令为16Bit或32Bit宽。以ATMEGA2560为例，它拥有256K Byte的FLASH，
但PC却只有17Bit，这是因为AVR的FLASH访问是以16Bit为单位的。

ⅲ.Atmega1280和Atmega2560虽然同为一个系列的单片机，但前者的PC只有16Bit，原因
是Atmega1280的FLASH只有64K x 16Bit。在移植是需要注意查看对应芯片的PC长度，以
免在堆栈操作时出现错误。

ⅳ.奇怪的一点是，ATmega640/1280/1281/2560/2561官方
datasheet(版本号2549M–AVR–09/10)上并未明确说明Atmega1280是否具
有EIND寄存器(但指出EICALL and EIJMP do not exist in ATmega640/1280/1281)，同
时编译器IAR Embedded Workbench for AVR(V5.40.1)相应器件的头文件中也未包含对EIND
寄存器的声明，只是在代码调试工具AVR Studio(V4.18)中能找到EIND的踪迹。此处以AVR 
Studio(V4.18)为准，因其是AVR官方调试工具。特修改IAR Embedded Workbench for 
AVR(V5.40.1)头文件库库文件iom1280.h，使其包含对EIND的声明以通过编译。

/******************************************************************************
*
*                 更详细的信息，应该查看代码和官方 datasheet。
*
******************************************************************************/













四、移植后的调试方式
ⅰ.为降低调试复杂性，完成移植文件的修改后，应该检验底层代码的正确性，而不应急着
建立用户任务。以下是示例代码:
void main(void)
{
	OSTaskStkSize     = OS_TASK_STK_SIZE;//os_cfg.h中已定义次宏
	OSTaskStkSizeHard = OS_TASK_HARD_STK_SIZE; //os_cfg.h中已定义次宏

	OSInit();

	OSStart();
}
如果OSTaskStkInit()和OSStartHighRdy()编写正确，则代码会执行OS_TaskIdle()。如果
不能，则需查看OSTaskStkInit()和OSStartHighRdy ()。建议先查看OSTaskStkInit()的硬
件堆栈初始化。





























ⅱ.确定OSTaskStkInit()和OSStartHighRdy ()是正确无误之后，此时可以建立两个用户任
务以检验OSCtxSw()。示例代码如下：

OS_STK	TestTask1Stk[OS_TASK_STK_SIZE];

void	TestTask1(void * p_arg);

void main( void )
{
  OSTaskStkSize     = OS_TASK_STK_SIZE;
  OSTaskStkSizeHard = OS_TASK_HARD_STK_SIZE;
  
  OSInit();

  OSTaskCreate(TestTask1, (void *)0, &TestTask1Stk[OS_TASK_STK_SIZE - 1], 2);
  
  OSStart();
}

void TestTask1(void * p_arg)
{
	p_arg = p_arg;

	TimeTickISRInit();

	for(;;){
		OSTimeDly(1);
	}
}

如果OSCtxSw()是正确，代码执行TestTask1()的OSTimeDly(1)后，切换至OS_TaskIdle()。
这个时候，移植工作一般可以说是完成了很大一部分。












ⅲ.到验证OSTickISR()和OSIntCtxSw()的时候。以下是示例代码：
OS_STK	TestTask1Stk[OS_TASK_STK_SIZE];

void	TestTask1(void * p_arg);
void	TimeTickISRInit(void);

void main( void )
{
  OSTaskStkSize     = OS_TASK_STK_SIZE;
  OSTaskStkSizeHard = OS_TASK_HARD_STK_SIZE;
  
  OSInit();

  OSTaskCreate(TestTask1, (void *)0, &TestTask1Stk[OS_TASK_STK_SIZE - 1], 2);
  
  OSStart();
}

void	TimeTickISRInit(void)
{
	TCCR0A=0x00;
	TCCR0B=0x05;
	TCNT0=0x00;
	OCR0A=0x00;
	OCR0B=0x00;	
	TIMSK0=0x01;
}

void TestTask1(void * p_arg)
{
	p_arg = p_arg;

	TimeTickISRInit();

	for(;;){
		OSTimeDly(1);
	}
}
如果OSTickISR()和OSIntCtxSw()是正确的，代码执行轨迹将会是: 
OSStartHighRdy()->TestTask1()->OSCtxSw()->OS_TaskIdle()->OSTickISR()->OSIntCtxSw
()->TestTask1()->OSCtxSw()->OS_TaskIdle()。如此循环。


